{"name":"Lean.Elab.Match","instances":[{"typeNames":["Lean.Elab.Term.Discr"],"name":"Lean.Elab.Term.instInhabitedDiscr","className":"Inhabited"}],"imports":["Init","Lean.Util.CollectFVars","Lean.Parser.Term","Lean.Meta.Match.MatchPatternAttr","Lean.Meta.Match.Match","Lean.Meta.GeneralizeVars","Lean.Meta.ForEachExpr","Lean.Elab.SyntheticMVars","Lean.Elab.Arg","Lean.Elab.PatternVar","Lean.Elab.AuxDiscr","Lean.Elab.BindersUtil"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L1283-L1295","name":"Lean.Elab.Term.elabNoMatch","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabNoMatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L1263-L1274","name":"Lean.Elab.Term.elabMatch.elabMatchDefault","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabMatch.elabMatchDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L1257-L1274","name":"Lean.Elab.Term.elabMatch","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabMatch","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L1012-L1022","name":"Lean.Elab.Term.reportMatcherResultErrors","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.reportMatcherResultErrors","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L1007-L1007","name":"Lean.Elab.Term.match.ignoreUnusedAlts","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.match.ignoreUnusedAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L1004-L1005","name":"Lean.Elab.Term.mkMatcher","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.mkMatcher","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L840-L846","name":"Lean.Elab.Term.GeneralizeResult","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.GeneralizeResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L734-L735","name":"Lean.Elab.Term.withDepElimPatterns","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.withDepElimPatterns","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L720-L729","name":"Lean.Elab.Term.ToDepElimPattern.main.unpack.go","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L719-L730","name":"Lean.Elab.Term.ToDepElimPattern.main.unpack","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L695-L717","name":"Lean.Elab.Term.ToDepElimPattern.main.pack","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.pack","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L676-L730","name":"Lean.Elab.Term.ToDepElimPattern.main","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main","doc":"Main method for `withDepElimPatterns`.\n- `PatternVarDecls`: are the explicit pattern variables provided by the user.\n- `ps`: are the patterns provided by the user.\n- `matchType`: the expected typ for this branch. It depends on the explicit pattern variables and the implicit ones that are still represented as metavariables,\n   and are found by this function.\n- `k` is the continuation that is executed in an updated local context with the all pattern variables (explicit and implicit). Note that, `patternVarDecls` are all\n   replaced since they may depend on implicit pattern variables (i.e., metavariables) that are converted into new free variables by this method.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L649-L665","name":"Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go","doc":"The `Bool` context is true iff we are inside of an \"inaccessible\" pattern. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L645-L665","name":"Lean.Elab.Term.ToDepElimPattern.savePatternInfo","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo","doc":"Save pattern information in the info tree, and remove `patternWithRef?` annotations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L605-L605","name":"Lean.Elab.Term.ToDepElimPattern.TopSortM","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSortM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L600-L603","name":"Lean.Elab.Term.ToDepElimPattern.TopSort.State","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSort.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L536-L554","name":"Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L526-L534","name":"Lean.Elab.Term.ToDepElimPattern.normalize.processVar","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.processVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L521-L524","name":"Lean.Elab.Term.ToDepElimPattern.normalize.addVar","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.addVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L469-L554","name":"Lean.Elab.Term.ToDepElimPattern.normalize","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize","doc":"Normalize the pattern and collect all patterns variables (explicit and implicit).\nThis method is the one that decides where the inaccessible annotations must be inserted.\nThe pattern variables are both free variables (for explicit pattern variables) and metavariables (for implicit ones).\nRecall that `mkLambdaFVars` now allows us to abstract both free variables and metavariables.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L394-L398","name":"Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar","doc":"Return true iff `e` is an explicit pattern variable provided by the user. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L391-L391","name":"Lean.Elab.Term.ToDepElimPattern.M","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L379-L389","name":"Lean.Elab.Term.ToDepElimPattern.Context","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L376-L377","name":"Lean.Elab.Term.ToDepElimPattern.State","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L222-L225","name":"Lean.Elab.Term.PatternElabException","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.PatternElabException","doc":"Auxiliary structure for storing an type mismatch exception when processing the\npattern #`idx` of some alternative. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L184-L185","name":"Lean.Elab.Term.PatternVarDecl","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.PatternVarDecl","doc":"We convert the collected `PatternVar`s intro `PatternVarDecl` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L173-L181","name":"Lean.Elab.Term.precheckMatch","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.precheckMatch","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L168-L170","name":"Lean.Elab.Term.elabInaccessible","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabInaccessible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L146-L149","name":"Lean.Elab.Term.expandMacrosInPatterns","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.expandMacrosInPatterns","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L76-L82","name":"Lean.Elab.Term.ElabMatchTypeAndDiscrsResult","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ElabMatchTypeAndDiscrsResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L74-L74","name":"Lean.Elab.Term.instInhabitedDiscr","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.instInhabitedDiscr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L70-L74","name":"Lean.Elab.Term.Discr","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.Discr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Match.lean#L52-L56","name":"Lean.Elab.Term.isAtomicDiscr?","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.isAtomicDiscr?","doc":"We treat `@x` as atomic to avoid unnecessary extra local declarations from being\n   inserted into the local context. Recall that `expandMatchAltsIntoMatch` uses `@` modifier.\n   Thus this is kind of discriminant is quite common.\n\n   Remark: if the discriminat is `Systax.missing`, we abort the elaboration of the `match`-expression.\n   This can happen due to error recovery. Example\n   ```\n   example : (p ∨ p) → p := fun h => match\n   ```\n   If we don't abort, the elaborator loops because we will keep trying to expand\n   ```\n   match\n   ```\n   into\n   ```\n   let d := <Syntax.missing>; match\n   ```\n   Recall that `Syntax.setArg stx i arg` is a no-op when `i` is out-of-bounds. "}]}